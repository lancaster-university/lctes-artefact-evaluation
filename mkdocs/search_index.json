{
    "docs": [
        {
            "location": "/", 
            "text": "Testing MakeCode and Codal\n\n\nOn this website, you will find the information required to reproduce our results gathered for the paper entitled \"MakeCode and Codal: Intuitive and Efficient Embedded Systems Programming for Education\" using the micro:bit. After reading the entirety of this page, at the top there is a drop down menu labelled \ntests\n which provides links to detailed documents on the tests we conducted for each environment using the micro:bit.\n\n\nPhysical requirements\n\n\n\n\nMust have a micro:bit\n\n\nMust have a copy of our debian virtual machine with testing environment.\n\n\nMust have an oscilloscope available.\n\n\n\n\nRequired ability\n\n\n\n\nMust be competent with debian, and terminal.\n\n\nMust have some experience with an oscilloscope, or are willing to learn how to use one!\n\n\nUnderstand how to use a serial terminal.\n\n\n\n\nTest procedure\n\n\nFirstly, a virtual machine needs to be downloaded, steps to do this are described in the section entitled \nObtaining the virtual machine\n.\n\n\nOnce you have obtained the virtual machine, the root directory for testing (\nevaluators\n) is arranged in the following form:\n\n\n\n\ncodal\n contains the codal build environment which you will use to conduct codal tests.\n\n\ndocs\n contains the documentation for tests and this overview document. We provide this website for convenience.\n\n\nespruino\n contains the espruino interpretter used when testing espruino.\n\n\nmakecode\n contains a modified copy of the executable web editor that can be run locally.\n\n\ntests\n contains all of the tests, grouped by each environment, their use is described in the \ndocs\n folder. e.g. \ndocs/codal.md\n describes all tests that are contained in \ntests/codal/*\n.\n\n\n\n\nTests either use a serial terminal to validate output, or use an oscilloscope to measure waveforms, in either case the setup pictured below should be adequate for both tests:\n\n\n\n\nThe micro:bit is connected to a PC over USB (top of the micro:bit), which also exposes a serial port for a PC to connect to for serial output from the micro:bit. When connected, the micro:bit will mount the VM at \n/media/lctes/MICROBIT\n so that it can be programmed -- it can be accessed using the FileVault application or through the terminal. Further instructions on programming the micro:bit are available \nhere\n.\n\n\nThe scope has one probe lead connected to channel one, this probe lead connects to the micro:bit's ground pin (far right of the micro:bit), and samples pin P1 (yellow cable connected to the micro:bit). All tests use pin P1, so no reconfiguration of this setup will be required. For information on how to use an oscilloscope we recommend this \nsparkfun tutorial\n.\n\n\nWe provide minicom installed on the virtual machine to observe serial results. From a terminal run \nminicom -D /dev/ttyACM0 -b 115200\n to communicate with the microbit. \n-D\n specifies the device, and \n-b\n specifies the baud rate. Pasting into minicom (or more widely, a terminal window) is done through using \nctrl + shift + v\n. To quit minicom, press \nctrl + a\n followed by \nq\n.\n\n\nWhat is a micro:bit?\n\n\nThe \nmicro:bit\n is a small embedded computer designed for computer science education, MakeCode and Codal were initially designed for the micro:bit, evolving and supporting other devices over time.\n\n\nObtaining the virtual machine\n\n\nThe virtual machine is contained here in \ngoogle drive\n, freely downloadable by anyone. You will need to install the \nVM VirtualBox Extension Pack\n.\n\n\nThe virtual machine contains a folder named \nevaluators\n which is placed in the home directory of the lctes user. The username for the virtual machine is: \nlctes\n and the password is: \nlctes2018\n. To become super user, type su in a terminal, and enter the same password (\nlctes2018\n).\n\n\nOnce logged in, and in the \nevaluators\n directory, you can view the tests as markdown files in the \ndocs\n directory. Alternately, these markdown documents can also be viewed on the web by running \nmkdocs serve\n in the evaluators folder, or browsing to: https://lancaster-university.github.io/lctes-artefact-evaluation/ which is a pre-built, and hosted version produced from the same source.\n\n\nWe recommend that you add the micro:bit usb device using the machine settings tab in virtual box as shown in the image below:\n\n\n\n\nWe also have a convenience script for mounting a shared folder between the host and the vm. Simply create a shared folder named \nlctes-vm-dir\n and run \nsh mount.sh\n (contained in \nevaluators\n) as a super user to mount the shared folder to vb-share (also contained in \nevaluators\n). Shared folder creation in VirtualBox is pictured below:", 
            "title": "Overview"
        }, 
        {
            "location": "/#testing-makecode-and-codal", 
            "text": "On this website, you will find the information required to reproduce our results gathered for the paper entitled \"MakeCode and Codal: Intuitive and Efficient Embedded Systems Programming for Education\" using the micro:bit. After reading the entirety of this page, at the top there is a drop down menu labelled  tests  which provides links to detailed documents on the tests we conducted for each environment using the micro:bit.", 
            "title": "Testing MakeCode and Codal"
        }, 
        {
            "location": "/#physical-requirements", 
            "text": "Must have a micro:bit  Must have a copy of our debian virtual machine with testing environment.  Must have an oscilloscope available.", 
            "title": "Physical requirements"
        }, 
        {
            "location": "/#required-ability", 
            "text": "Must be competent with debian, and terminal.  Must have some experience with an oscilloscope, or are willing to learn how to use one!  Understand how to use a serial terminal.", 
            "title": "Required ability"
        }, 
        {
            "location": "/#test-procedure", 
            "text": "Firstly, a virtual machine needs to be downloaded, steps to do this are described in the section entitled  Obtaining the virtual machine .  Once you have obtained the virtual machine, the root directory for testing ( evaluators ) is arranged in the following form:   codal  contains the codal build environment which you will use to conduct codal tests.  docs  contains the documentation for tests and this overview document. We provide this website for convenience.  espruino  contains the espruino interpretter used when testing espruino.  makecode  contains a modified copy of the executable web editor that can be run locally.  tests  contains all of the tests, grouped by each environment, their use is described in the  docs  folder. e.g.  docs/codal.md  describes all tests that are contained in  tests/codal/* .   Tests either use a serial terminal to validate output, or use an oscilloscope to measure waveforms, in either case the setup pictured below should be adequate for both tests:   The micro:bit is connected to a PC over USB (top of the micro:bit), which also exposes a serial port for a PC to connect to for serial output from the micro:bit. When connected, the micro:bit will mount the VM at  /media/lctes/MICROBIT  so that it can be programmed -- it can be accessed using the FileVault application or through the terminal. Further instructions on programming the micro:bit are available  here .  The scope has one probe lead connected to channel one, this probe lead connects to the micro:bit's ground pin (far right of the micro:bit), and samples pin P1 (yellow cable connected to the micro:bit). All tests use pin P1, so no reconfiguration of this setup will be required. For information on how to use an oscilloscope we recommend this  sparkfun tutorial .  We provide minicom installed on the virtual machine to observe serial results. From a terminal run  minicom -D /dev/ttyACM0 -b 115200  to communicate with the microbit.  -D  specifies the device, and  -b  specifies the baud rate. Pasting into minicom (or more widely, a terminal window) is done through using  ctrl + shift + v . To quit minicom, press  ctrl + a  followed by  q .", 
            "title": "Test procedure"
        }, 
        {
            "location": "/#what-is-a-microbit", 
            "text": "The  micro:bit  is a small embedded computer designed for computer science education, MakeCode and Codal were initially designed for the micro:bit, evolving and supporting other devices over time.", 
            "title": "What is a micro:bit?"
        }, 
        {
            "location": "/#obtaining-the-virtual-machine", 
            "text": "The virtual machine is contained here in  google drive , freely downloadable by anyone. You will need to install the  VM VirtualBox Extension Pack .  The virtual machine contains a folder named  evaluators  which is placed in the home directory of the lctes user. The username for the virtual machine is:  lctes  and the password is:  lctes2018 . To become super user, type su in a terminal, and enter the same password ( lctes2018 ).  Once logged in, and in the  evaluators  directory, you can view the tests as markdown files in the  docs  directory. Alternately, these markdown documents can also be viewed on the web by running  mkdocs serve  in the evaluators folder, or browsing to: https://lancaster-university.github.io/lctes-artefact-evaluation/ which is a pre-built, and hosted version produced from the same source.  We recommend that you add the micro:bit usb device using the machine settings tab in virtual box as shown in the image below:   We also have a convenience script for mounting a shared folder between the host and the vm. Simply create a shared folder named  lctes-vm-dir  and run  sh mount.sh  (contained in  evaluators ) as a super user to mount the shared folder to vb-share (also contained in  evaluators ). Shared folder creation in VirtualBox is pictured below:", 
            "title": "Obtaining the virtual machine"
        }, 
        {
            "location": "/codal/", 
            "text": "Testing codal\n\n\nThe tests we conducted are listed below.\n\n\nGPIO toggle time\n\n\nThis test is used to determine the time taken to toggle the GPIO. This time is then used as an offset in other other tests to remove this delay from our results.\n\n\nSteps to reproduce\n\n\n\n\nEnsure \n./codal/config.json\n has \ndebug\n and \nheap_debug\n set to 0.\n\n\nCopy the contents of \ntests/codal/gpio-base/BaseGPIOTest.cpp\n to \ncodal/source/main.cpp\n.\n\n\nCompile the program by running \nyt clean \n yt build\n in \n./codal\n.\n\n\nFrom \n./codal\n copy \nbuild/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex\n to the microbit.\n\n\nMeasure the positive width of the pulse using an oscilloscope, 1us per division.\n\n\n\n\nTest code\n\n\n#include \nMicroBit.h\n\n\nMicroBit uBit;\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nint main()\n{\n    uBit.init();\n    while(1)\n    {\n        set_gpio(1,1);\n        set_gpio(1,0);\n    }\n}\n\n\n\n\nWhere is this result used?\n\n\nIn each result where time is reported.\n\n\nContext switch time\n\n\nThis test determines the cost of our stack duplication approach with respect to time. We page between two fibers, and observe the impact this has on execution time using GPIO and an oscilloscope.\n\n\nSteps to reproduce\n\n\n\n\nEnsure \n./codal/config.json\n has \ndebug\n and \nheap_debug\n set to 0.\n\n\nCopy the contents of \ntests/codal/context-switch-time/ContextSwitchTest.cpp\n to \ncodal/source/main.cpp\n.\n\n\nCompile the program by running \nyt clean \n yt build\n in \n./codal\n.\n\n\nFrom \n./codal\n copy \nbuild/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex\n to the microbit.\n\n\nMeasure the positive width of the pulse using an oscilloscope, 1us per division.\n\n\n\n\nDo not forget to subtract the time taken to toggle a GPIO from these results.\n\n\nTest code\n\n\n#include \nMicroBit.h\n\n\nMicroBit uBit;\n\n#define BUFFER_SIZE 0\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nvoid high()\n{\n#if BUFFER_SIZE \n 0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n\n    while(1)\n    {\n        set_gpio(1,1);\n        schedule();\n    }\n}\n\nvoid low()\n{\n#if BUFFER_SIZE \n 0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n    while(1)\n    {\n        set_gpio(1,0);\n        schedule();\n    }\n}\n\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    create_fiber(low);\n    create_fiber(high);\n\n    release_fiber();\n}\n\n\n\n\nWhere is this result used?\n\n\nFigure 7, where we report context switch time vs. stack size, and Figure 6, where we report the context switch profiles for each device.\n\n\nContext switch longitudinal test\n\n\nThis test determines the cost of our stack duplication approach with respect to time. We force bytes onto the stack in two fibers, paging between them, and observe the impact this has on execution time using GPIO and an oscilloscope.\n\n\nSteps to reproduce\n\n\n\n\nEnsure \n./codal/config.json\n has \ndebug\n and \nheap_debug\n set to 0.\n\n\nCopy the contents of \ntests/codal/context-switch-time/ContextSwitchTest.cpp\n to \ncodal/source/main.cpp\n.\n\n\nCompile the program by running \nyt clean \n yt build\n in \n./codal\n.\n\n\nFrom \n./codal\n copy \nbuild/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex\n to the microbit.\n\n\nMeasure the positive width of the pulse using an oscilloscope.\n\n\nRepeat steps 1 - 4 modifying the \nBUFFER_SIZE\n define at the top of the main program in increasing powers of 2.\n\n\n\n\nDo not forget to subtract the time taken to toggle a GPIO from these results.\n\n\nTest code\n\n\n#include \nMicroBit.h\n\n\nMicroBit uBit;\n\n#define BUFFER_SIZE 0\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nvoid high()\n{\n#if BUFFER_SIZE \n 0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n\n    while(1)\n    {\n        set_gpio(1,1);\n        schedule();\n    }\n}\n\nvoid low()\n{\n#if BUFFER_SIZE \n 0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n    while(1)\n    {\n        set_gpio(1,0);\n        schedule();\n    }\n}\n\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    create_fiber(low);\n    create_fiber(high);\n\n    release_fiber();\n}\n\n\n\n\nWhere is this result used?\n\n\nFigure 7, where we report context switch time vs. stack size.\n\n\nTight loop execution time\n\n\nThis test counts from 0 to 100,000 using C++. After a full iteration, a GPIO is toggled, allowing us to calculate the time using an oscilloscope.\n\n\nSteps to reproduce\n\n\n\n\nEnsure \n./codal/config.json\n has \ndebug\n and \nheap_debug\n set to 0.\n\n\nCopy the contents of \ntests/codal/tight-loop/TightLoopTest.cpp\n to \ncodal/source/main.cpp\n.\n\n\nCompile the program by running \nyt clean \n yt build\n in \n./codal\n.\n\n\nFrom \n./codal\n copy \nbuild/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex\n to the microbit.\n\n\nMeasure the positive width of the pulse using an oscilloscope, 100ms per division should be adequate.\n\n\n\n\nTest code\n\n\n\n#include \nMicroBit.h\n\n\nMicroBit uBit;\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    while(1)\n    {\n        set_gpio(1,1);\n        for(volatile int i = 0; i \n 100000; i++)\n        {\n            i =i;\n        }\n        set_gpio(1,0);\n        for(volatile int i = 0; i \n 100000; i++)\n        {\n            i =i;\n        }\n    }\n\n    release_fiber();\n}\n\n\n\n\nWhere is this result used?\n\n\nTable 2, where we report the execution speed of each environment compared to MakeCode and Codal.\n\n\nContext switch stack usage\n\n\nThis test is used to determine the default stack depth in codal, and thus it's contribution to the time taken to page out the stack.\n\n\nSteps to reproduce\n\n\n\n\nSet \ndebug\n and \nheap_debug\n in \n./codal/config.json\n to 1.\n\n\nCopy the contents of \ntests/codal/context-switch-time/ContextSwitchTest.cpp\n to \ncodal/source/main.cpp\n.\n\n\nCompile the program by running \nyt clean \n yt build\n in \n./codal\n.\n\n\nFrom \n./codal\n copy \nbuild/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex\n to the microbit.\n\n\nIn minicom (\ndescribed here\n) the output should read \nsd: xxx bufferSize: xx\n, the former shows the default stack depth in bytes for each fiber, the latter shows the amount of bytes allocated to contain the stack.\n\n\n\n\nTest code\n\n\n#include \nMicroBit.h\n\n\nMicroBit uBit;\n\n#define BUFFER_SIZE 0\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nvoid high()\n{\n#if BUFFER_SIZE \n 0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n\n    while(1)\n    {\n        set_gpio(1,1);\n        schedule();\n    }\n}\n\nvoid low()\n{\n#if BUFFER_SIZE \n 0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n    while(1)\n    {\n        set_gpio(1,0);\n        schedule();\n    }\n}\n\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    create_fiber(low);\n    create_fiber(high);\n\n    release_fiber();\n}\n\n\n\n\nWhere is this result used?\n\n\nFigure 6, where we show the context switch time per device, broken down by environment. We calculate each segment (Codal, Stack, MakeCode) using the time data gathered in the context switch time test. We then use codal as the benchmark to compute the impact of the stack for each; subtracting codal, and stack page times, gives us the overhead of MakeCode.\n\n\nMemory consumption\n\n\nThis results for this test are calculated when determining the consumption of MakeCode, please see \"Memory consumption\" in \nmakecode\n.", 
            "title": "Codal"
        }, 
        {
            "location": "/codal/#testing-codal", 
            "text": "The tests we conducted are listed below.", 
            "title": "Testing codal"
        }, 
        {
            "location": "/codal/#gpio-toggle-time", 
            "text": "This test is used to determine the time taken to toggle the GPIO. This time is then used as an offset in other other tests to remove this delay from our results.", 
            "title": "GPIO toggle time"
        }, 
        {
            "location": "/codal/#steps-to-reproduce", 
            "text": "Ensure  ./codal/config.json  has  debug  and  heap_debug  set to 0.  Copy the contents of  tests/codal/gpio-base/BaseGPIOTest.cpp  to  codal/source/main.cpp .  Compile the program by running  yt clean   yt build  in  ./codal .  From  ./codal  copy  build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex  to the microbit.  Measure the positive width of the pulse using an oscilloscope, 1us per division.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/codal/#test-code", 
            "text": "#include  MicroBit.h \n\nMicroBit uBit;\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nint main()\n{\n    uBit.init();\n    while(1)\n    {\n        set_gpio(1,1);\n        set_gpio(1,0);\n    }\n}", 
            "title": "Test code"
        }, 
        {
            "location": "/codal/#where-is-this-result-used", 
            "text": "In each result where time is reported.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/codal/#context-switch-time", 
            "text": "This test determines the cost of our stack duplication approach with respect to time. We page between two fibers, and observe the impact this has on execution time using GPIO and an oscilloscope.", 
            "title": "Context switch time"
        }, 
        {
            "location": "/codal/#steps-to-reproduce_1", 
            "text": "Ensure  ./codal/config.json  has  debug  and  heap_debug  set to 0.  Copy the contents of  tests/codal/context-switch-time/ContextSwitchTest.cpp  to  codal/source/main.cpp .  Compile the program by running  yt clean   yt build  in  ./codal .  From  ./codal  copy  build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex  to the microbit.  Measure the positive width of the pulse using an oscilloscope, 1us per division.   Do not forget to subtract the time taken to toggle a GPIO from these results.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/codal/#test-code_1", 
            "text": "#include  MicroBit.h \n\nMicroBit uBit;\n\n#define BUFFER_SIZE 0\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nvoid high()\n{\n#if BUFFER_SIZE   0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n\n    while(1)\n    {\n        set_gpio(1,1);\n        schedule();\n    }\n}\n\nvoid low()\n{\n#if BUFFER_SIZE   0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n    while(1)\n    {\n        set_gpio(1,0);\n        schedule();\n    }\n}\n\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    create_fiber(low);\n    create_fiber(high);\n\n    release_fiber();\n}", 
            "title": "Test code"
        }, 
        {
            "location": "/codal/#where-is-this-result-used_1", 
            "text": "Figure 7, where we report context switch time vs. stack size, and Figure 6, where we report the context switch profiles for each device.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/codal/#context-switch-longitudinal-test", 
            "text": "This test determines the cost of our stack duplication approach with respect to time. We force bytes onto the stack in two fibers, paging between them, and observe the impact this has on execution time using GPIO and an oscilloscope.", 
            "title": "Context switch longitudinal test"
        }, 
        {
            "location": "/codal/#steps-to-reproduce_2", 
            "text": "Ensure  ./codal/config.json  has  debug  and  heap_debug  set to 0.  Copy the contents of  tests/codal/context-switch-time/ContextSwitchTest.cpp  to  codal/source/main.cpp .  Compile the program by running  yt clean   yt build  in  ./codal .  From  ./codal  copy  build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex  to the microbit.  Measure the positive width of the pulse using an oscilloscope.  Repeat steps 1 - 4 modifying the  BUFFER_SIZE  define at the top of the main program in increasing powers of 2.   Do not forget to subtract the time taken to toggle a GPIO from these results.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/codal/#test-code_2", 
            "text": "#include  MicroBit.h \n\nMicroBit uBit;\n\n#define BUFFER_SIZE 0\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nvoid high()\n{\n#if BUFFER_SIZE   0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n\n    while(1)\n    {\n        set_gpio(1,1);\n        schedule();\n    }\n}\n\nvoid low()\n{\n#if BUFFER_SIZE   0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n    while(1)\n    {\n        set_gpio(1,0);\n        schedule();\n    }\n}\n\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    create_fiber(low);\n    create_fiber(high);\n\n    release_fiber();\n}", 
            "title": "Test code"
        }, 
        {
            "location": "/codal/#where-is-this-result-used_2", 
            "text": "Figure 7, where we report context switch time vs. stack size.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/codal/#tight-loop-execution-time", 
            "text": "This test counts from 0 to 100,000 using C++. After a full iteration, a GPIO is toggled, allowing us to calculate the time using an oscilloscope.", 
            "title": "Tight loop execution time"
        }, 
        {
            "location": "/codal/#steps-to-reproduce_3", 
            "text": "Ensure  ./codal/config.json  has  debug  and  heap_debug  set to 0.  Copy the contents of  tests/codal/tight-loop/TightLoopTest.cpp  to  codal/source/main.cpp .  Compile the program by running  yt clean   yt build  in  ./codal .  From  ./codal  copy  build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex  to the microbit.  Measure the positive width of the pulse using an oscilloscope, 100ms per division should be adequate.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/codal/#test-code_3", 
            "text": "#include  MicroBit.h \n\nMicroBit uBit;\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    while(1)\n    {\n        set_gpio(1,1);\n        for(volatile int i = 0; i   100000; i++)\n        {\n            i =i;\n        }\n        set_gpio(1,0);\n        for(volatile int i = 0; i   100000; i++)\n        {\n            i =i;\n        }\n    }\n\n    release_fiber();\n}", 
            "title": "Test code"
        }, 
        {
            "location": "/codal/#where-is-this-result-used_3", 
            "text": "Table 2, where we report the execution speed of each environment compared to MakeCode and Codal.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/codal/#context-switch-stack-usage", 
            "text": "This test is used to determine the default stack depth in codal, and thus it's contribution to the time taken to page out the stack.", 
            "title": "Context switch stack usage"
        }, 
        {
            "location": "/codal/#steps-to-reproduce_4", 
            "text": "Set  debug  and  heap_debug  in  ./codal/config.json  to 1.  Copy the contents of  tests/codal/context-switch-time/ContextSwitchTest.cpp  to  codal/source/main.cpp .  Compile the program by running  yt clean   yt build  in  ./codal .  From  ./codal  copy  build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex  to the microbit.  In minicom ( described here ) the output should read  sd: xxx bufferSize: xx , the former shows the default stack depth in bytes for each fiber, the latter shows the amount of bytes allocated to contain the stack.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/codal/#test-code_4", 
            "text": "#include  MicroBit.h \n\nMicroBit uBit;\n\n#define BUFFER_SIZE 0\n\nvoid set_gpio(int pin_number, int state)\n{\n    switch(pin_number)\n    {\n        case 0:\n            uBit.io.P0.setDigitalValue(state);\n            break;\n        case 1:\n            uBit.io.P1.setDigitalValue(state);\n            break;\n        case 2:\n            uBit.io.P2.setDigitalValue(state);\n            break;\n    }\n}\n\nvoid high()\n{\n#if BUFFER_SIZE   0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n\n    while(1)\n    {\n        set_gpio(1,1);\n        schedule();\n    }\n}\n\nvoid low()\n{\n#if BUFFER_SIZE   0\n    volatile char b[BUFFER_SIZE] = {0};\n#endif\n\n    while(1)\n    {\n        set_gpio(1,0);\n        schedule();\n    }\n}\n\n\nint main()\n{\n    uBit.init();\n\n    set_gpio(1,0);\n\n    create_fiber(low);\n    create_fiber(high);\n\n    release_fiber();\n}", 
            "title": "Test code"
        }, 
        {
            "location": "/codal/#where-is-this-result-used_4", 
            "text": "Figure 6, where we show the context switch time per device, broken down by environment. We calculate each segment (Codal, Stack, MakeCode) using the time data gathered in the context switch time test. We then use codal as the benchmark to compute the impact of the stack for each; subtracting codal, and stack page times, gives us the overhead of MakeCode.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/codal/#memory-consumption", 
            "text": "This results for this test are calculated when determining the consumption of MakeCode, please see \"Memory consumption\" in  makecode .", 
            "title": "Memory consumption"
        }, 
        {
            "location": "/espruino/", 
            "text": "Testing Espruino\n\n\nThe tests we conducted are listed below.\n\n\nTight loop execution time\n\n\nThis test is used to determine the overhead of a full interpretter on the microbit. The test runs a tight spin loop using a python program toggling a gpio every 100,000 increments of a count.\n\n\nSteps to reproduce\n\n\n\n\nFlash \nespruino_1v95_microbit.hex\n to the microbit.\n\n\nConnect minicom (\ndescribed here\n) to the microbit at 9600 baud.\n\n\nCopy and paste \n./tests/espruino/tight-loop/tight-loop.js\n into minicom.\n\n\nSet oscilloscope to 25s per division.\n\n\nMeasure the result.\n\n\n\n\nTest code\n\n\nwhile(true){digitalWrite(D1,false); for(var i = 0; i \n 100000; i++){i=i;} digitalWrite(D1,true); for(var i = 0; i \n 100000; i++){i=i;} }\n\n\n\n\nWhere is this result used?\n\n\nTable 2, where we report the execution speed of each environment compared to MakeCode and Codal.", 
            "title": "Espruino"
        }, 
        {
            "location": "/espruino/#testing-espruino", 
            "text": "The tests we conducted are listed below.", 
            "title": "Testing Espruino"
        }, 
        {
            "location": "/espruino/#tight-loop-execution-time", 
            "text": "This test is used to determine the overhead of a full interpretter on the microbit. The test runs a tight spin loop using a python program toggling a gpio every 100,000 increments of a count.", 
            "title": "Tight loop execution time"
        }, 
        {
            "location": "/espruino/#steps-to-reproduce", 
            "text": "Flash  espruino_1v95_microbit.hex  to the microbit.  Connect minicom ( described here ) to the microbit at 9600 baud.  Copy and paste  ./tests/espruino/tight-loop/tight-loop.js  into minicom.  Set oscilloscope to 25s per division.  Measure the result.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/espruino/#test-code", 
            "text": "while(true){digitalWrite(D1,false); for(var i = 0; i   100000; i++){i=i;} digitalWrite(D1,true); for(var i = 0; i   100000; i++){i=i;} }", 
            "title": "Test code"
        }, 
        {
            "location": "/espruino/#where-is-this-result-used", 
            "text": "Table 2, where we report the execution speed of each environment compared to MakeCode and Codal.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/makecode/", 
            "text": "Testing MakeCode\n\n\nTo test MakeCode, the process is slightly more involved, due to the web-based nature and many stages of compilation, in order to provide the user with the ability to compile in-the-browser.\n\n\nTo conduct tests accurately, you will need to perform a few modifications and intricate compile steps. These will be documented as clearly as possible.\n\n\nThe tests we conducted are listed below.\n\n\n\n\nWarning\n\n\nPlease ignore any warnings from the MakeCode editor when running these tests. We didn't add required simulations for new code we added to conduct these tests.\n\n\n\n\nGPIO toggle time\n\n\nThis test is used to determine the time taken to toggle the GPIO. This time is then used as an offset in other other tests to remove this delay from our results.\n\n\nSteps to reproduce\n\n\n\n\nDestroy any running local makecode instances by killing the server, and closing the browser.\n\n\nEnsure \n./makecode/pxt-microbit/libs/core/pxt.json\n has \ndebug\n and \nheap_debug\n set to 0.\n\n\nChange to the \n./makecode/pxt-microbit\n directory.\n\n\nRun \npxt serve\n and wait until a web browser opens with a local instance of MakeCode.\n\n\nCopy the contents of \nroot/tests/makecode/gpio-base/GPIO-test.ts\n into the editor window.\n\n\nHit download to download the compiled program as a hex file.\n\n\nDrag the file using the files GUI or use the \ncp\n command to copy the hex file to the micro:bit\n\n\nUse an oscilloscope set to 10us per division and measure the output.\n\n\n\n\nTest code\n\n\nfunction set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nwhile (true) {\n    set_gpio(1);\n    set_gpio(0);\n}\n\n\n\n\n\nWhere is this result used?\n\n\nIn each result where time is reported.\n\n\nContext switch time\n\n\nThis test determines the cost of our stack duplication approach with respect to time in MakeCode. We page between two fibers, and observe the impact this has on execution time using GPIO and an oscilloscope.\n\n\nSteps to reproduce\n\n\n\n\nDestroy any running local makecode instances by killing the server, and closing the browser.\n\n\nEnsure \n./makecode/pxt-microbit/libs/core/pxt.json\n has \ndebug\n and \nheap_debug\n set to 0.\n\n\nChange to the \n./makecode/pxt-microbit\n directory.\n\n\nRun \npxt serve\n and wait until a web browser opens with a local instance of MakeCode.\n\n\nCopy the contents of \nroot/tests/makecode/context-switch-time/context-switch-test.ts\n into the editor window.\n\n\nHit download to download the compiled program as a hex file.\n\n\nDrag the file using the files GUI or use the \ncp\n command to copy the hex file to the micro:bit\n\n\nUse an oscilloscope set to 25us per division and measure the output.\n\n\n\n\nDo not forget to subtract the time taken to toggle a GPIO from these results.\n\n\nTest code\n\n\nfunction set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nfunction high() {\n    while (1) {\n        set_gpio(1);\n        control.spinScheduler();\n    }\n}\n\nfunction low() {\n    while (1) {\n        set_gpio(0);\n        control.spinScheduler();\n    }\n}\n\nset_gpio(0);\n\ncontrol.inBackground(high)\ncontrol.inBackground(low)\n\ncontrol.releaseFiber();\n\n\n\n\nWhere is this result used?\n\n\nFigure 7, where we report context switch time vs. stack size, and Figure 6, where we report the context switch profiles for each device.\n\n\nTight loop execution time\n\n\nThis test counts from 0 to 100,000, using the higher level language in MakeCode, TypeScript. After a full iteration, a GPIO is toggled, allowing us to calculate the time using an oscilloscope.\n\n\nSteps to reproduce\n\n\n\n\nDestroy any running local makecode instances by killing the server, and closing the browser.\n\n\nEnsure \n./makecode/pxt-microbit/libs/core/pxt.json\n has \ndebug\n and \nheap_debug\n set to 0.\n\n\nChange to the \n./makecode/pxt-microbit\n directory.\n\n\nRun \npxt serve\n and wait until a web browser opens with a local instance of MakeCode.\n\n\nCopy the contents of \nroot/tests/makecode/tight-loop/tight-loop-test.ts\n into the editor window.\n\n\nHit download to download the compiled program as a hex file.\n\n\nDrag the file using the files GUI or use the \ncp\n command to copy the hex file to the micro:bit\n\n\nUse an oscilloscope set to 25us per division and measure the output.\n\n\n\n\nTest code\n\n\nfunction set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nwhile (true) {\n    set_gpio(0);\n    for (let i = 0; i \n 100000; i++) {\n        i = i;\n    }\n    set_gpio(1);\n    for (let i = 0; i \n 100000; i++) {\n        i = i;\n    }\n}\n\n\n\n\nWhere is this result used?\n\n\nTable 2, where we report the execution speed of each environment compared to MakeCode and Codal.\n\n\nMemory consumption\n\n\nThis test uses the map file generated by PXT to break down all libraries into individual units, and computes the RAM / Flash cost of each.\n\n\nSteps to reproduce\n\n\n\n\nEnsure \n./makecode/pxt-microbit/libs/core/pxt.json\n has \ndebug\n and \nheap_debug\n set to 0 and was built previously with these settings.\n\n\nChange to the \n./makecode/pxt-microbit\n directory.\n\n\nRun \nnode ../../tests/makecode/memory-consumption/map-file-stats.js ./libs/blocksprj/built/yt/build/bbc-microbit-classic-gcc/source/pxt-microbit-app.map\n in your terminal.\n\n\nCompute the results. Results with 'RAM' in front, indicate pre-allocated RAM in the globals or bss space. Results without 'RAM' in front are flash sizes. Both are reported in kB.\n\n\n\n\nExample\n\n\nGiven the following memory map:\n\n\nroot@debian-lctes:/home/lctes/evaluators/makecode/pxt-microbit# node ../../tests/makecode/memory-consumption/map-file-stats.js ./libs/blocksprj/built/yt/build/bbc-microbit-classic-gcc/source/pxt-microbit-app.map\nTOTAL 94.342\nRAM.TOTAL 170.707\nRAM.xr 160\nRAM.xrw 8\nlib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.07\nlib/thumb/v6-m/crt0.o 0.117\nlibs/blocksprj/built/yt/source/core/pins.cpp.o 0.852\nlibs/blocksprj/built/yt/source/core/serial.cpp.o 0.383\nlibs/blocksprj/built/yt/source/core/pxt.cpp.o 3.877\nlibs/blocksprj/built/yt/source/core/images.cpp.o 0.365\nlibs/blocksprj/built/yt/source/core/control.cpp.o 0.137\nlibs/blocksprj/built/yt/source/core/core.cpp.o 1.396\nlibs/blocksprj/built/yt/source/core/ManagedBuffer.cpp.o 0.74\nlibs/blocksprj/built/yt/source/core/led.cpp.o 0.27\nlibs/blocksprj/built/yt/source/pointers.cpp.o 0.785\nlibs/blocksprj/built/yt/source/radio/radio.cpp.o 1.471\nlibs/blocksprj/built/yt/source/main.cpp.o 0.027\nlibs/blocksprj/built/yt/source/core/input.cpp.o 0.623\nlibs/blocksprj/built/yt/source/core/basic.cpp.o 0.432\nym/microbit/source/microbit.a 1.063\nym/microbit-dal/source/microbit-dal.a 33.063\nym/ble/source/ble.a 0.431\nym/ble-nrf51822/source/ble-nrf51822.a 9.088\nym/nrf51-sdk/source/nrf51-sdk.a 7.268\nym/mbed-classic/existing/mbed-classic.a 7.346\nlibstdc++_nano.a 0.459\nlibgcc.a 12.531\nlibm.a 7.418\nlibc_nano.a 3.463\nlibnosys.a 0.031\nlibs/blocksprj/built/yt/source/core/buffer.cpp.o 0.639\nRAM.lib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.031\nRAM.ym/microbit-dal/source/microbit-dal.a 0.214\nRAM.ym/nrf51-sdk/source/nrf51-sdk.a 0.461\nRAM.ym/mbed-classic/existing/mbed-classic.a 0.251\nRAM.libc_nano.a 0.461\nRAM.ym/ble-nrf51822/source/ble-nrf51822.a 0.191\nRAM.libm.a 0.001\nRAM.libs/blocksprj/built/yt/source/core/pxt.cpp.o 1.039\nRAM.libs/blocksprj/built/yt/source/core/pins.cpp.o 0.008\nRAM.libs/blocksprj/built/yt/source/radio/radio.cpp.o 0.022\nRAM.ym/ble/source/ble.a 0.02\nRAM.libstdc++_nano.a 0.004\nRAM.libnosys.a 0.004\n\n\n\n\nWe can derive the following:\n\n\nlibs/blocksprj/built/yt/source/core/pins.cpp.o 0.852\nlibs/blocksprj/built/yt/source/core/serial.cpp.o 0.383\nlibs/blocksprj/built/yt/source/core/pxt.cpp.o 3.877\nlibs/blocksprj/built/yt/source/core/images.cpp.o 0.365\nlibs/blocksprj/built/yt/source/core/control.cpp.o 0.137\nlibs/blocksprj/built/yt/source/core/core.cpp.o 1.396\nlibs/blocksprj/built/yt/source/core/ManagedBuffer.cpp.o 0.74\nlibs/blocksprj/built/yt/source/core/led.cpp.o 0.27\nlibs/blocksprj/built/yt/source/pointers.cpp.o 0.785\nlibs/blocksprj/built/yt/source/radio/radio.cpp.o 1.471\nlibs/blocksprj/built/yt/source/main.cpp.o 0.027\nlibs/blocksprj/built/yt/source/core/input.cpp.o 0.623\nlibs/blocksprj/built/yt/source/core/basic.cpp.o 0.432\nlibs/blocksprj/built/yt/source/core/buffer.cpp.o 0.639\n\n\n\n\nSummed is 11.997, and relates to \u201cMakeCode\u201d in Table 3.\n\n\nym/microbit/source/microbit.a 1.063\nym/microbit-dal/source/microbit-dal.a 33.063\n\n\n\n\nSummed is 34.126, and relates to \u201cCODAL\u201d in Table 3.\n\n\nym/ble/source/ble.a 0.431\nym/ble-nrf51822/source/ble-nrf51822.a 9.088\nym/nrf51-sdk/source/nrf51-sdk.a 7.268\nym/mbed-classic/existing/mbed-classic.a 7.346\n\n\n\n\nSummed is 24.133, and relates to \u201cSupporting Libraries\u201d in Table 3.\n\n\nlibstdc++_nano.a 0.459\nlibgcc.a 12.531\nlibm.a 7.418\nlibc_nano.a 3.463\nlibnosys.a 0.031\nlib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.07\nlib/thumb/v6-m/crt0.o 0.117\n\n\n\n\nSummed is 24.089, and relates to \u201cC++ Standard Library\u201d in Table 3.\n\n\nRAM.libs/blocksprj/built/yt/source/core/pxt.cpp.o 1.039\nRAM.libs/blocksprj/built/yt/source/core/pins.cpp.o 0.008\nRAM.libs/blocksprj/built/yt/source/radio/radio.cpp.o 0.022\n\n\n\n\nSummed is 1.069, and relates to \u201cMakeCode\u201d in Table 4.\n\n\nRAM.ym/microbit-dal/source/microbit-dal.a 0.214\n\n\n\n\nSummed is 0.214, and relates to \u201cCODAL\u201d in Table 4.\n\n\nRAM.ym/nrf51-sdk/source/nrf51-sdk.a 0.461\nRAM.ym/mbed-classic/existing/mbed-classic.a 0.251\nRAM.ym/ble-nrf51822/source/ble-nrf51822.a 0.191\nRAM.ym/ble/source/ble.a 0.02\n\n\n\n\nSummed is 0.923, and relates to \u201cSupporting Libraries\u201d in Table 4.\n\n\nRAM.lib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.031\nRAM.libc_nano.a 0.461\nRAM.libm.a 0.001\nRAM.libstdc++_nano.a 0.004\nRAM.libnosys.a 0.004\n\n\n\n\nSummed is 0.501, and should relate to \u201cC++ Standard Library\u201d in Table 4. The outlier in this result is libc_nano, which we originally found to be 0.109kb. The discrepancies in the final flash and RAM sizes calculated is down to the older version of gcc that is running on the VM. We compiled using arm-none-eabi-gcc v7.02.\n\n\nWhere is this result used?\n\n\nTables 4 and 5, where we report the flash and RAM usage of individual compilation units.\n\n\nContext switch stack usage\n\n\nThis test is used to determine the default stack depth in MakeCode, and thus it's contribution to the time taken to page out the stack.\n\n\nSteps to reproduce\n\n\n\n\nDestroy any running local makecode instances by killing the server, and closing the browser.\n\n\nSet \ndebug\n and \nheap_debug\n in \n./makecode/pxt-microbit/libs/core/pxt.json\n to 1.\n\n\nChange to the \n./makecode/pxt-microbit\n directory.\n\n\nRun \npxt serve\n and wait until a web browser opens with a local instance of MakeCode.\n\n\nCopy the contents of \nroot/tests/makecode/context-switch-time/context-switch-test.ts\n into the editor window.\n\n\nHit download to download the compiled program as a hex file.\n\n\nDrag the file using the files GUI or use the \ncp\n command to copy the hex file to the micro:bit\n\n\nIn minicom (\ndescribed here\n) the output should read \nsd: xxx bufferSize: xx\n, the former shows the default stack depth in bytes for each fiber, the latter shows the amount of bytes allocated to contain the stack.\n\n\n\n\nTest code\n\n\nfunction set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nfunction high() {\n    while (1) {\n        set_gpio(1);\n        control.spinScheduler();\n    }\n}\n\nfunction low() {\n    while (1) {\n        set_gpio(0);\n        control.spinScheduler();\n    }\n}\n\nset_gpio(0);\n\ncontrol.inBackground(high)\ncontrol.inBackground(low)\n\ncontrol.releaseFiber();\n\n\n\n\nWhere is this result used?\n\n\nFigure 6, where we show the context switch time per device, broken down by environment. We calculate each segment (Codal, Stack, MakeCode) using the time data gathered in the context switch time test. We then use codal as the benchmark to compute the impact of the stack for each; subtracting codal, and stack page times, gives us the overhead of MakeCode.", 
            "title": "MakeCode"
        }, 
        {
            "location": "/makecode/#testing-makecode", 
            "text": "To test MakeCode, the process is slightly more involved, due to the web-based nature and many stages of compilation, in order to provide the user with the ability to compile in-the-browser.  To conduct tests accurately, you will need to perform a few modifications and intricate compile steps. These will be documented as clearly as possible.  The tests we conducted are listed below.   Warning  Please ignore any warnings from the MakeCode editor when running these tests. We didn't add required simulations for new code we added to conduct these tests.", 
            "title": "Testing MakeCode"
        }, 
        {
            "location": "/makecode/#gpio-toggle-time", 
            "text": "This test is used to determine the time taken to toggle the GPIO. This time is then used as an offset in other other tests to remove this delay from our results.", 
            "title": "GPIO toggle time"
        }, 
        {
            "location": "/makecode/#steps-to-reproduce", 
            "text": "Destroy any running local makecode instances by killing the server, and closing the browser.  Ensure  ./makecode/pxt-microbit/libs/core/pxt.json  has  debug  and  heap_debug  set to 0.  Change to the  ./makecode/pxt-microbit  directory.  Run  pxt serve  and wait until a web browser opens with a local instance of MakeCode.  Copy the contents of  root/tests/makecode/gpio-base/GPIO-test.ts  into the editor window.  Hit download to download the compiled program as a hex file.  Drag the file using the files GUI or use the  cp  command to copy the hex file to the micro:bit  Use an oscilloscope set to 10us per division and measure the output.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/makecode/#test-code", 
            "text": "function set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nwhile (true) {\n    set_gpio(1);\n    set_gpio(0);\n}", 
            "title": "Test code"
        }, 
        {
            "location": "/makecode/#where-is-this-result-used", 
            "text": "In each result where time is reported.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/makecode/#context-switch-time", 
            "text": "This test determines the cost of our stack duplication approach with respect to time in MakeCode. We page between two fibers, and observe the impact this has on execution time using GPIO and an oscilloscope.", 
            "title": "Context switch time"
        }, 
        {
            "location": "/makecode/#steps-to-reproduce_1", 
            "text": "Destroy any running local makecode instances by killing the server, and closing the browser.  Ensure  ./makecode/pxt-microbit/libs/core/pxt.json  has  debug  and  heap_debug  set to 0.  Change to the  ./makecode/pxt-microbit  directory.  Run  pxt serve  and wait until a web browser opens with a local instance of MakeCode.  Copy the contents of  root/tests/makecode/context-switch-time/context-switch-test.ts  into the editor window.  Hit download to download the compiled program as a hex file.  Drag the file using the files GUI or use the  cp  command to copy the hex file to the micro:bit  Use an oscilloscope set to 25us per division and measure the output.   Do not forget to subtract the time taken to toggle a GPIO from these results.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/makecode/#test-code_1", 
            "text": "function set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nfunction high() {\n    while (1) {\n        set_gpio(1);\n        control.spinScheduler();\n    }\n}\n\nfunction low() {\n    while (1) {\n        set_gpio(0);\n        control.spinScheduler();\n    }\n}\n\nset_gpio(0);\n\ncontrol.inBackground(high)\ncontrol.inBackground(low)\n\ncontrol.releaseFiber();", 
            "title": "Test code"
        }, 
        {
            "location": "/makecode/#where-is-this-result-used_1", 
            "text": "Figure 7, where we report context switch time vs. stack size, and Figure 6, where we report the context switch profiles for each device.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/makecode/#tight-loop-execution-time", 
            "text": "This test counts from 0 to 100,000, using the higher level language in MakeCode, TypeScript. After a full iteration, a GPIO is toggled, allowing us to calculate the time using an oscilloscope.", 
            "title": "Tight loop execution time"
        }, 
        {
            "location": "/makecode/#steps-to-reproduce_2", 
            "text": "Destroy any running local makecode instances by killing the server, and closing the browser.  Ensure  ./makecode/pxt-microbit/libs/core/pxt.json  has  debug  and  heap_debug  set to 0.  Change to the  ./makecode/pxt-microbit  directory.  Run  pxt serve  and wait until a web browser opens with a local instance of MakeCode.  Copy the contents of  root/tests/makecode/tight-loop/tight-loop-test.ts  into the editor window.  Hit download to download the compiled program as a hex file.  Drag the file using the files GUI or use the  cp  command to copy the hex file to the micro:bit  Use an oscilloscope set to 25us per division and measure the output.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/makecode/#test-code_2", 
            "text": "function set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nwhile (true) {\n    set_gpio(0);\n    for (let i = 0; i   100000; i++) {\n        i = i;\n    }\n    set_gpio(1);\n    for (let i = 0; i   100000; i++) {\n        i = i;\n    }\n}", 
            "title": "Test code"
        }, 
        {
            "location": "/makecode/#where-is-this-result-used_2", 
            "text": "Table 2, where we report the execution speed of each environment compared to MakeCode and Codal.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/makecode/#memory-consumption", 
            "text": "This test uses the map file generated by PXT to break down all libraries into individual units, and computes the RAM / Flash cost of each.", 
            "title": "Memory consumption"
        }, 
        {
            "location": "/makecode/#steps-to-reproduce_3", 
            "text": "Ensure  ./makecode/pxt-microbit/libs/core/pxt.json  has  debug  and  heap_debug  set to 0 and was built previously with these settings.  Change to the  ./makecode/pxt-microbit  directory.  Run  node ../../tests/makecode/memory-consumption/map-file-stats.js ./libs/blocksprj/built/yt/build/bbc-microbit-classic-gcc/source/pxt-microbit-app.map  in your terminal.  Compute the results. Results with 'RAM' in front, indicate pre-allocated RAM in the globals or bss space. Results without 'RAM' in front are flash sizes. Both are reported in kB.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/makecode/#example", 
            "text": "Given the following memory map:  root@debian-lctes:/home/lctes/evaluators/makecode/pxt-microbit# node ../../tests/makecode/memory-consumption/map-file-stats.js ./libs/blocksprj/built/yt/build/bbc-microbit-classic-gcc/source/pxt-microbit-app.map\nTOTAL 94.342\nRAM.TOTAL 170.707\nRAM.xr 160\nRAM.xrw 8\nlib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.07\nlib/thumb/v6-m/crt0.o 0.117\nlibs/blocksprj/built/yt/source/core/pins.cpp.o 0.852\nlibs/blocksprj/built/yt/source/core/serial.cpp.o 0.383\nlibs/blocksprj/built/yt/source/core/pxt.cpp.o 3.877\nlibs/blocksprj/built/yt/source/core/images.cpp.o 0.365\nlibs/blocksprj/built/yt/source/core/control.cpp.o 0.137\nlibs/blocksprj/built/yt/source/core/core.cpp.o 1.396\nlibs/blocksprj/built/yt/source/core/ManagedBuffer.cpp.o 0.74\nlibs/blocksprj/built/yt/source/core/led.cpp.o 0.27\nlibs/blocksprj/built/yt/source/pointers.cpp.o 0.785\nlibs/blocksprj/built/yt/source/radio/radio.cpp.o 1.471\nlibs/blocksprj/built/yt/source/main.cpp.o 0.027\nlibs/blocksprj/built/yt/source/core/input.cpp.o 0.623\nlibs/blocksprj/built/yt/source/core/basic.cpp.o 0.432\nym/microbit/source/microbit.a 1.063\nym/microbit-dal/source/microbit-dal.a 33.063\nym/ble/source/ble.a 0.431\nym/ble-nrf51822/source/ble-nrf51822.a 9.088\nym/nrf51-sdk/source/nrf51-sdk.a 7.268\nym/mbed-classic/existing/mbed-classic.a 7.346\nlibstdc++_nano.a 0.459\nlibgcc.a 12.531\nlibm.a 7.418\nlibc_nano.a 3.463\nlibnosys.a 0.031\nlibs/blocksprj/built/yt/source/core/buffer.cpp.o 0.639\nRAM.lib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.031\nRAM.ym/microbit-dal/source/microbit-dal.a 0.214\nRAM.ym/nrf51-sdk/source/nrf51-sdk.a 0.461\nRAM.ym/mbed-classic/existing/mbed-classic.a 0.251\nRAM.libc_nano.a 0.461\nRAM.ym/ble-nrf51822/source/ble-nrf51822.a 0.191\nRAM.libm.a 0.001\nRAM.libs/blocksprj/built/yt/source/core/pxt.cpp.o 1.039\nRAM.libs/blocksprj/built/yt/source/core/pins.cpp.o 0.008\nRAM.libs/blocksprj/built/yt/source/radio/radio.cpp.o 0.022\nRAM.ym/ble/source/ble.a 0.02\nRAM.libstdc++_nano.a 0.004\nRAM.libnosys.a 0.004  We can derive the following:  libs/blocksprj/built/yt/source/core/pins.cpp.o 0.852\nlibs/blocksprj/built/yt/source/core/serial.cpp.o 0.383\nlibs/blocksprj/built/yt/source/core/pxt.cpp.o 3.877\nlibs/blocksprj/built/yt/source/core/images.cpp.o 0.365\nlibs/blocksprj/built/yt/source/core/control.cpp.o 0.137\nlibs/blocksprj/built/yt/source/core/core.cpp.o 1.396\nlibs/blocksprj/built/yt/source/core/ManagedBuffer.cpp.o 0.74\nlibs/blocksprj/built/yt/source/core/led.cpp.o 0.27\nlibs/blocksprj/built/yt/source/pointers.cpp.o 0.785\nlibs/blocksprj/built/yt/source/radio/radio.cpp.o 1.471\nlibs/blocksprj/built/yt/source/main.cpp.o 0.027\nlibs/blocksprj/built/yt/source/core/input.cpp.o 0.623\nlibs/blocksprj/built/yt/source/core/basic.cpp.o 0.432\nlibs/blocksprj/built/yt/source/core/buffer.cpp.o 0.639  Summed is 11.997, and relates to \u201cMakeCode\u201d in Table 3.  ym/microbit/source/microbit.a 1.063\nym/microbit-dal/source/microbit-dal.a 33.063  Summed is 34.126, and relates to \u201cCODAL\u201d in Table 3.  ym/ble/source/ble.a 0.431\nym/ble-nrf51822/source/ble-nrf51822.a 9.088\nym/nrf51-sdk/source/nrf51-sdk.a 7.268\nym/mbed-classic/existing/mbed-classic.a 7.346  Summed is 24.133, and relates to \u201cSupporting Libraries\u201d in Table 3.  libstdc++_nano.a 0.459\nlibgcc.a 12.531\nlibm.a 7.418\nlibc_nano.a 3.463\nlibnosys.a 0.031\nlib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.07\nlib/thumb/v6-m/crt0.o 0.117  Summed is 24.089, and relates to \u201cC++ Standard Library\u201d in Table 3.  RAM.libs/blocksprj/built/yt/source/core/pxt.cpp.o 1.039\nRAM.libs/blocksprj/built/yt/source/core/pins.cpp.o 0.008\nRAM.libs/blocksprj/built/yt/source/radio/radio.cpp.o 0.022  Summed is 1.069, and relates to \u201cMakeCode\u201d in Table 4.  RAM.ym/microbit-dal/source/microbit-dal.a 0.214  Summed is 0.214, and relates to \u201cCODAL\u201d in Table 4.  RAM.ym/nrf51-sdk/source/nrf51-sdk.a 0.461\nRAM.ym/mbed-classic/existing/mbed-classic.a 0.251\nRAM.ym/ble-nrf51822/source/ble-nrf51822.a 0.191\nRAM.ym/ble/source/ble.a 0.02  Summed is 0.923, and relates to \u201cSupporting Libraries\u201d in Table 4.  RAM.lib/gcc/arm-none-eabi/7.2.1/thumb/v6-m/crtbegin.o 0.031\nRAM.libc_nano.a 0.461\nRAM.libm.a 0.001\nRAM.libstdc++_nano.a 0.004\nRAM.libnosys.a 0.004  Summed is 0.501, and should relate to \u201cC++ Standard Library\u201d in Table 4. The outlier in this result is libc_nano, which we originally found to be 0.109kb. The discrepancies in the final flash and RAM sizes calculated is down to the older version of gcc that is running on the VM. We compiled using arm-none-eabi-gcc v7.02.", 
            "title": "Example"
        }, 
        {
            "location": "/makecode/#where-is-this-result-used_3", 
            "text": "Tables 4 and 5, where we report the flash and RAM usage of individual compilation units.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/makecode/#context-switch-stack-usage", 
            "text": "This test is used to determine the default stack depth in MakeCode, and thus it's contribution to the time taken to page out the stack.", 
            "title": "Context switch stack usage"
        }, 
        {
            "location": "/makecode/#steps-to-reproduce_4", 
            "text": "Destroy any running local makecode instances by killing the server, and closing the browser.  Set  debug  and  heap_debug  in  ./makecode/pxt-microbit/libs/core/pxt.json  to 1.  Change to the  ./makecode/pxt-microbit  directory.  Run  pxt serve  and wait until a web browser opens with a local instance of MakeCode.  Copy the contents of  root/tests/makecode/context-switch-time/context-switch-test.ts  into the editor window.  Hit download to download the compiled program as a hex file.  Drag the file using the files GUI or use the  cp  command to copy the hex file to the micro:bit  In minicom ( described here ) the output should read  sd: xxx bufferSize: xx , the former shows the default stack depth in bytes for each fiber, the latter shows the amount of bytes allocated to contain the stack.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/makecode/#test-code_3", 
            "text": "function set_gpio(state: number) {\n    pins.digitalWritePin(DigitalPin.P1, state)\n}\n\nfunction high() {\n    while (1) {\n        set_gpio(1);\n        control.spinScheduler();\n    }\n}\n\nfunction low() {\n    while (1) {\n        set_gpio(0);\n        control.spinScheduler();\n    }\n}\n\nset_gpio(0);\n\ncontrol.inBackground(high)\ncontrol.inBackground(low)\n\ncontrol.releaseFiber();", 
            "title": "Test code"
        }, 
        {
            "location": "/makecode/#where-is-this-result-used_4", 
            "text": "Figure 6, where we show the context switch time per device, broken down by environment. We calculate each segment (Codal, Stack, MakeCode) using the time data gathered in the context switch time test. We then use codal as the benchmark to compute the impact of the stack for each; subtracting codal, and stack page times, gives us the overhead of MakeCode.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/micropython/", 
            "text": "Testing micropython\n\n\nThe tests we conducted are listed below.\n\n\nTight loop execution time (byte code compiled)\n\n\nThis test is used to determine the overhead of a bytecode interpretter on the microbit. The test runs a tight spin loop using a python program toggling a gpio every 100,000 increments of a count.\n\n\nA precompiled hex file (\n./test/micropython/tight-loop/compiled/microbit-micropython-bytecode-compiled.hex\n) is provided for convenience.\n\n\nSteps to reproduce\n\n\n\n\nNavigate to the \nmicropython online editor\n\n\nCopy the contents of \n./tests/micropython/tight-loop/compiled/tight-loop-compiled-test.py\n into the editor.\n\n\nClick download and drag the outputted hex file onto the microbit device.\n\n\nSet oscilloscope to 10s per division.\n\n\nMeasure the width of the high pulse.\n\n\n\n\nWhere is this result used?\n\n\nTable 2, where we report the execution speed of each environment compared to MakeCode and Codal.\n\n\nTight loop execution time (fully interpretted)\n\n\nThis test is used to determine the overhead of a full interpretter on the microbit. The test runs a tight spin loop using a python program toggling a gpio every 100,000 increments of a count.\n\n\nSteps to reproduce\n\n\n\n\nFlash \n./micropython/microbit-micropython.hex\n (the full interpretter) onto the microbit.\n\n\nConnect minicom (\ndescribed here\n)to the microbit at 115200 baud.\n\n\nPress \nctrl + e\n in minicom to enter paste mode (\n should change to \n===\n)\n\n\nCopy and paste \n./tests/tight-loop/interpeted/tight-loop-test.py\n into minicom.\n\n\nPress \nctrl + d\n to begin execution\n\n\nSet oscilloscope to 50s per division.\n\n\nMeasure the width of the high pulse.\n\n\n\n\nTest code\n\n\nwhile True:\n    pin1.write_digital(0)\n\n    for i in range(0,100000):\n        i = i\n\n    pin1.write_digital(1)\n\n    for i in range(0,100000):\n        i = i\n\n\n\n\nWhere is this result used?\n\n\nThis result is not used, but will appear in Table 2, where we report the execution speed of each environment compared to MakeCode and Codal for Camera Ready.", 
            "title": "micropython"
        }, 
        {
            "location": "/micropython/#testing-micropython", 
            "text": "The tests we conducted are listed below.", 
            "title": "Testing micropython"
        }, 
        {
            "location": "/micropython/#tight-loop-execution-time-byte-code-compiled", 
            "text": "This test is used to determine the overhead of a bytecode interpretter on the microbit. The test runs a tight spin loop using a python program toggling a gpio every 100,000 increments of a count.  A precompiled hex file ( ./test/micropython/tight-loop/compiled/microbit-micropython-bytecode-compiled.hex ) is provided for convenience.", 
            "title": "Tight loop execution time (byte code compiled)"
        }, 
        {
            "location": "/micropython/#steps-to-reproduce", 
            "text": "Navigate to the  micropython online editor  Copy the contents of  ./tests/micropython/tight-loop/compiled/tight-loop-compiled-test.py  into the editor.  Click download and drag the outputted hex file onto the microbit device.  Set oscilloscope to 10s per division.  Measure the width of the high pulse.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/micropython/#where-is-this-result-used", 
            "text": "Table 2, where we report the execution speed of each environment compared to MakeCode and Codal.", 
            "title": "Where is this result used?"
        }, 
        {
            "location": "/micropython/#tight-loop-execution-time-fully-interpretted", 
            "text": "This test is used to determine the overhead of a full interpretter on the microbit. The test runs a tight spin loop using a python program toggling a gpio every 100,000 increments of a count.", 
            "title": "Tight loop execution time (fully interpretted)"
        }, 
        {
            "location": "/micropython/#steps-to-reproduce_1", 
            "text": "Flash  ./micropython/microbit-micropython.hex  (the full interpretter) onto the microbit.  Connect minicom ( described here )to the microbit at 115200 baud.  Press  ctrl + e  in minicom to enter paste mode (  should change to  === )  Copy and paste  ./tests/tight-loop/interpeted/tight-loop-test.py  into minicom.  Press  ctrl + d  to begin execution  Set oscilloscope to 50s per division.  Measure the width of the high pulse.", 
            "title": "Steps to reproduce"
        }, 
        {
            "location": "/micropython/#test-code", 
            "text": "while True:\n    pin1.write_digital(0)\n\n    for i in range(0,100000):\n        i = i\n\n    pin1.write_digital(1)\n\n    for i in range(0,100000):\n        i = i", 
            "title": "Test code"
        }, 
        {
            "location": "/micropython/#where-is-this-result-used_1", 
            "text": "This result is not used, but will appear in Table 2, where we report the execution speed of each environment compared to MakeCode and Codal for Camera Ready.", 
            "title": "Where is this result used?"
        }
    ]
}